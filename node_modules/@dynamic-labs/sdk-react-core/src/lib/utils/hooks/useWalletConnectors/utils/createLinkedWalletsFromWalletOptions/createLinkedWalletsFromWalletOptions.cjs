'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var sdkApiCore = require('@dynamic-labs/sdk-api-core');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var findWalletOptionFor = require('../../../../functions/findWalletOptionFor/findWalletOptionFor.cjs');
var shouldManuallyReconnectOnRefresh = require('../../../../functions/shouldManuallyReconnectOnRefresh/shouldManuallyReconnectOnRefresh.cjs');
var convertLegacyPhantomLedgerConnector = require('../convertLegacyPhantomLedgerConnector/convertLegacyPhantomLedgerConnector.cjs');
var smartWallet = require('../smartWallet/smartWallet.cjs');

const createLinkedWalletsFromWalletOptions = ({ user, walletConnectorOptions, primaryWalletId, separateSmartWalletAndSigner, }) => {
    // wallet state should be null while loading all the wallets or when there is no user
    if (!walletConnectorOptions || !user) {
        return [];
    }
    return user.verifiedCredentials
        .map(convertLegacyPhantomLedger)
        .map((account) => {
        var _a, _b;
        const wallet = findWalletOptionFor.findWalletOptionFor(account, walletConnectorOptions);
        // this probably shouldn't happen. this would mean that the user has an account linked
        // with wallet W, but the customer has toggled off wallet W or the chain that
        // supports wallet W
        /* istanbul ignore next */
        if (!wallet)
            return null;
        if (account.id === primaryWalletId &&
            shouldManuallyReconnectOnRefresh.shouldManuallyReconnectOnRefresh(wallet.walletConnector)) {
            wallet.walletConnector.connect();
        }
        // only checking for ledger hardware wallets since we only specify ledger as a hardware wallet
        if (((_a = account.walletProperties) === null || _a === void 0 ? void 0 : _a.hardwareWallet) ===
            sdkApiCore.HardwareWalletEnum.Ledger &&
            walletConnectorCore.isHardwareWalletConnector(wallet.walletConnector)) {
            wallet.walletConnector.isHardwareWalletEnabled = true;
        }
        // this account is the owner of a smart wallet, and should not be surfaced
        if (!separateSmartWalletAndSigner &&
            smartWallet.isOwnerOfASmartWallet(account, user.verifiedCredentials)) {
            return null;
        }
        if (account.address && account.chain) {
            if (account.walletProvider === sdkApiCore.WalletProviderEnum.SmartContractWallet) {
                smartWallet.initializeSmartWallet({
                    account,
                    primaryWalletId,
                    verifiedCredentials: user.verifiedCredentials,
                    walletConnectorOptions,
                });
            }
            return wallet.walletConnector.createWallet({
                additionalAddresses: account.walletAdditionalAddresses,
                address: account.address,
                chain: wallet.walletConnector.connectedChain,
                connector: wallet.walletConnector,
                id: account.id,
                isAuthenticated: true,
                key: (_b = account.walletName) !== null && _b !== void 0 ? _b : wallet.walletConnector.key,
            });
        }
        return null;
    })
        .filter((wc) => wc !== null);
};
const convertLegacyPhantomLedger = (account) => {
    if (account.walletName === 'phantomledger') {
        return convertLegacyPhantomLedgerConnector.convertLegacyPhantomLedgerConnector(account);
    }
    return account;
};

exports.createLinkedWalletsFromWalletOptions = createLinkedWalletsFromWalletOptions;
